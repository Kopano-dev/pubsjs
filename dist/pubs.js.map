{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap d66f255090a80fbe79df","webpack:///./src/pubs.ts","webpack:///./src/events.ts","webpack:///./src/models.ts","webpack:///./src/utils.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_IMPORTED_MODULE_2__utils__","PubsDefaultOptions","authorizationValue","authorizationType","connectTimeout","reconnectInterval","maxReconnectInterval","reconnectEnabled","reconnectFactor","reconnectSpreader","heartbeatInterval","streamAckTimeout","websocketSequence","Pubs","[object Object]","baseURI","options","connecting","connected","reconnecting","closing","reconnector","reconnectAttempts","replace","assign","defaultOptions","replyHandlers","Map","console","debug","clearTimeout","fast","reconnectTimeout","Math","trunc","pow","floor","random","window","setTimeout","connect","dispatchStateChangedEvent","Promise","resolve","reject","__awaiter","connectResponse","authorizationHeader","fetchStreamWebSocketConnect","err","warn","streamUrl","error","code","msg","dispatchErrorEvent","__WEBPACK_IMPORTED_MODULE_1__models__","streamURL","includes","connectStreamWebSocket","undefined","then","topics","pubsub","type","payload","state","info","sendStreamWebSocketPayload","log","url","headers","Headers","set","fetch","method","mode","response","ok","json","status","statusText","uri","socket","oldSocket","closeStreamWebsocket","WebSocket","isTimeout","timeout","Error","onopen","event","target","onmessage","handleStreamWebSocketMessage","bind","onclose","onerror","replyTimeout","String","send","JSON","stringify","close","message","parse","data","delete","dispatchStreamEvent","constructor","getName","__WEBPACK_IMPORTED_MODULE_0__events__","onstatechanged","onstreamevent","dispatchEvent","version","PubsBaseEvent","eventName","PubsStateChangedEvent","super","PubsStreamEvent","PubsErrorEvent","details","__webpack_exports__","a","document","createElement","href"],"mappings":"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","file":"pubs.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Pubs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Pubs\"] = factory();\n\telse\n\t\troot[\"Pubs\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d66f255090a80fbe79df","/*!\n * Copyright 2018 Kopano\n *\n * Use of this source code is governed by a MIT license\n * that can be found in the LICENSE.txt file.\n *\n * @author   Kopano <https://kopano.com>\n * @license  MIT\n * @preserve\n */\n\n'use strict';\n\nimport {\n\tPubsErrorEvent,\n\tPubsStreamEvent,\n\tPubsStateChangedEvent,\n} from './events';\nimport {\n\tIStreamEnvelope,\n\tIStreamInfo,\n\tIStreamWebsocketConnectResponse,\n\tIStreamReplyTimeoutRecord,\n\tIPubsDataError,\n\tPubsDataError,\n} from './models';\nimport {\n\tmakeAbsoluteURL,\n} from './utils';\n\nconst authorizationTypeBearer = 'Bearer';\n\nexport interface IPubsOptions {\n\tauthorizationValue: string;\n\tauthorizationType: string;\n\tconnectTimeout: number;\n\treconnectInterval: number;\n\tmaxReconnectInterval: number;\n\treconnectEnabled: boolean;\n\treconnectFactor: number;\n\treconnectSpreader: number;\n\theartbeatInterval: number;\n\tstreamAckTimeout: number;\n}\n\nconst PubsDefaultOptions : IPubsOptions = {\n\tauthorizationValue: '',\n\tauthorizationType: authorizationTypeBearer,\n\tconnectTimeout: 5000,\n\treconnectInterval: 1000,\n\tmaxReconnectInterval: 30000,\n\treconnectEnabled: true,\n\treconnectFactor: 1.5,\n\treconnectSpreader: 500,\n\theartbeatInterval: 5000,\n\tstreamAckTimeout: 20000,\n}\n\n/**\n * The sequence counter for sent websocket message payloads. It is automatically\n * incremented whenever a payload message is sent via [[Pubs.sendWebSocketPayload]].\n * @private\n */\nlet websocketSequence = 0;\n\n\nexport class Pubs {\n\tpublic static version: string = __VERSION__;\n\n\t/**\n\t * Initialized Pubs defaults with the provided options.\n\t *\n\t * @param options Additional options.\n\t */\n\tpublic static init(options: IPubsOptions) {\n\t\tthis.defaultOptions = {...PubsDefaultOptions, ...options}\n\t}\n\n\tprivate static defaultOptions: IPubsOptions;\n\n\t/**\n\t * Boolean flag wether Pubs is currently trying to establish a connection.\n\t */\n\tpublic connecting: boolean = false;\n\n\t/**\n\t * Boolean flag wether Pubs is currently connected or not.\n\t */\n\tpublic connected: boolean = false;\n\n\t/**\n\t * Boolean flag wether Pubs is automatically reconnecting or not.\n\t */\n\tpublic reconnecting: boolean = false;\n\n\t/**\n\t * Event handler for [[PubsStateChangedEvent]]. Set to a function to get called\n\t * whenever [[PubsStateChangedEvent]]s are triggered.\n\t */\n\tpublic onstatechanged?: (event: PubsStateChangedEvent) => void;\n\n\t/**\n\t * Event handler for [[PubsErrorEvent]]. Set to a function to get called\n\t * whenever [[PubsErrorEvent]]s are triggered.\n\t */\n\tpublic onerror?: (event: PubsErrorEvent ) => void;\n\n\t/**\n\t * Event handler for [[PubsStreamEvent]]. Set to a function to get called\n\t * whenever [[PubsStreamEvent]]s are triggered.\n\t */\n\tpublic onstreamevent?: (event: PubsStreamEvent ) => void;\n\n\n\tprivate baseURI: string;\n\tprivate options: IPubsOptions;\n\tprivate socket?: WebSocket;\n\tprivate closing: boolean = false;\n\tprivate reconnector: number = 0;\n\tprivate reconnectAttempts: number = 0;\n\tprivate replyHandlers: Map<string, IStreamReplyTimeoutRecord>;\n\n\t/**\n\t * Creates a Pubs instance with the provided parameters.\n\t *\n\t * @param baseURI The base URI to the Pubs server API.\n\t * @param options Additional options.\n\t */\n\tconstructor(baseURI: string = '', options?: IPubsOptions) {\n\t\tthis.baseURI = baseURI.replace(/\\/$/, '');\n\t\tthis.options = {...PubsDefaultOptions, ...Pubs.defaultOptions, ...options};\n\t\tthis.replyHandlers = new Map<string, IStreamReplyTimeoutRecord>();\n\t}\n\n\t/**\n\t * Establish Websocket connection to Pubs server.\n\t *\n\t * @returns Promise which resolves when the connection was established.\n\t */\n\tpublic async connect(): Promise<void> {\n\t\tconsole.debug('pubs: connect');\n\n\t\tclearTimeout(this.reconnector);\n\t\tconst reconnector = (fast: boolean = false): void => {\n\t\t\tclearTimeout(this.reconnector);\n\t\t\tif (!this.reconnecting) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet reconnectTimeout = this.options.reconnectInterval;\n\t\t\tif (!fast) {\n\t\t\t\treconnectTimeout *= Math.trunc(Math.pow(this.options.reconnectFactor, this.reconnectAttempts));\n\t\t\t\tif (reconnectTimeout > this.options.maxReconnectInterval) {\n\t\t\t\t\treconnectTimeout = this.options.maxReconnectInterval;\n\t\t\t\t}\n\t\t\t\treconnectTimeout += Math.floor(Math.random() * this.options.reconnectSpreader);\n\t\t\t}\n\t\t\tthis.reconnector = window.setTimeout(() => {\n\t\t\t\tthis.connect();\n\t\t\t}, reconnectTimeout);\n\t\t\tthis.reconnectAttempts++;\n\t\t};\n\n\t\tthis.reconnecting = (this.options.reconnectEnabled || true);\n\t\tthis.connecting = true;\n\t\tthis.dispatchStateChangedEvent();\n\n\t\treturn new Promise<void>(async (resolve, reject) => {\n\t\t\tlet connectResponse: IStreamWebsocketConnectResponse;\n\t\t\tlet authorizationHeader: string = '';\n\t\t\tif (this.options.authorizationType && this.options.authorizationValue) {\n\t\t\t\tauthorizationHeader = this.options.authorizationType + ' ' + this.options.authorizationValue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconnectResponse = await this.fetchStreamWebSocketConnect(authorizationHeader);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.warn('pubs: failed to fetch websocket connection details', err);\n\t\t\t\tconnectResponse = {\n\t\t\t\t\tstreamUrl: '',\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'request_failed',\n\t\t\t\t\t\tmsg: '' + err,\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tconsole.debug('connect result', connectResponse);\n\t\t\tif (!connectResponse.streamUrl) {\n\t\t\t\tthis.connecting = false;\n\t\t\t\tthis.dispatchStateChangedEvent();\n\t\t\t\tif (this.reconnecting) {\n\t\t\t\t\tif (connectResponse.error && connectResponse.error.code === 'http_error_403') {\n\t\t\t\t\t\tconsole.warn('pubs: giving up reconnect, as connect returned forbidden', connectResponse.error.msg);\n\t\t\t\t\t\tthis.reconnecting = false;\n\t\t\t\t\t\tthis.dispatchStateChangedEvent();\n\t\t\t\t\t\tthis.dispatchErrorEvent(connectResponse.error);\n\t\t\t\t\t}\n\t\t\t\t\treconnector();\n\t\t\t\t} else if (connectResponse.error) {\n\t\t\t\t\treject(new PubsDataError(connectResponse.error));\n\t\t\t\t} else {\n\t\t\t\t\treject(new PubsDataError({code: 'unknown_error', msg: ''}));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet streamURL = connectResponse.streamUrl;\n\t\t\tif (!streamURL.includes('://')) {\n\t\t\t\t// Prefix with base when not absolute already.\n\t\t\t\tstreamURL = this.baseURI + streamURL;\n\t\t\t}\n\t\t\tthis.connectStreamWebSocket(streamURL, this.reconnecting ? reconnector : undefined).then(() => {\n\t\t\t\tthis.reconnectAttempts = 0;\n\t\t\t\tconsole.debug('pubs: connection established', this.reconnectAttempts);\n\t\t\t\tresolve();\n\t\t\t}, (err: any) => {\n\t\t\t\tconsole.warn('pubs: connection failed', err, !!this.reconnecting);\n\t\t\t\tif (this.reconnecting) {\n\t\t\t\t\treconnector();\n\t\t\t\t} else {\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Subscribe to topics.\n\t *\n\t * @param topics The array of topics to subscribe.\n\t * @returns Promise which resolves when the topics were subscribed.\n\t */\n\tpublic async sub(topics: string[]): Promise<void> {\n\t\t/// {\"type\": \"sub\", \"state\": \"123\", \"info\": {\"topics\": [\"lala\"]}}\n\t\treturn this.pubsub('sub', topics);\n\t}\n\n\t/**\n\t * Unsubscribe from topics.\n\t *\n\t * @param topics The array of topics to subscribe.\n\t * @returns Promise which resolves when the topics were subscribed.\n\t */\n\tpublic async unsub(topics: string[]): Promise<void> {\n\t\treturn this.pubsub('unsub', topics);\n\t}\n\n\tprivate async pubsub(type: string, topics: string[]): Promise<void> {\n\t\tconst payload = {\n\t\t\ttype: type,\n\t\t\tstate: '',\n\t\t\tinfo: {\n\t\t\t\t'topics': topics,\n\t\t\t},\n\t\t};\n\t\treturn this.sendStreamWebSocketPayload(payload).then(() => {\n\t\t\tconsole.log('pubs: send done')\n\t\t})\n\t}\n\n\t/**\n\t * Call Pubs connect via REST to retrieve Websocket stream endpoint details.\n\t *\n\t * @param user The user ID.\n\t * @param authorizationHeader Authorization HTTP request header value.\n\t * @returns Promise with the unmarshalled response data once received.\n\t */\n\tprivate async fetchStreamWebSocketConnect(authorizationHeader?: string): Promise<IStreamWebsocketConnectResponse> {\n\t\tconst url = this.baseURI + '/api/pubs/v1/stream/connect';\n\t\tconst headers = new Headers();\n\t\tif (authorizationHeader) {\n\t\t\theaders.set('Authorization', authorizationHeader);\n\t\t}\n\n\t\treturn fetch(url, {\n\t\t\theaders,\n\t\t\tmethod: 'POST',\n\t\t\tmode: 'cors',\n\t\t}).then(response => {\n\t\t\tif (!response.ok) {\n\t\t\t\treturn {\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: 'http_error_' + response.status,\n\t\t\t\t\t\tmsg: response.statusText,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn response.json();\n\t\t});\n\t}\n\n\t/**\n\t * Create a new Pubs stream Websocket connection using the provided uri. If\n\t * the accociated Pubs instance already has a connection, the old connection\n\t * will be closed before the new connection is established.\n\t *\n\t * @param uri URI or URL to use. The value will be made absolute if not\n\t *        already absolute. The scheme will be transformed to `ws:` or `wss:`\n\t *        if `http:` or `https:`.\n\t */\n\tprivate async connectStreamWebSocket(uri: string, reconnector?: (fast?: boolean) => void): Promise<WebSocket> {\n\t\tconsole.debug('pubs: connect stream websocket', uri);\n\n\t\treturn new Promise<WebSocket>((resolve, reject) => {\n\t\t\tif (this.socket) {\n\t\t\t\tconsole.warn('pubs: closing existing socket connection');\n\t\t\t\tconst oldSocket = this.socket;\n\t\t\t\tthis.socket = undefined;\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.closeStreamWebsocket(oldSocket);\n\t\t\t}\n\n\t\t\tconst url = makeAbsoluteURL(uri).replace(/^https:\\/\\//i, 'wss://').replace(/^http:\\/\\//i, 'ws://');\n\t\t\tconsole.debug('pubs: connecting stream socket URL', url);\n\t\t\tconst socket = new WebSocket(url+'?v=1');\n\n\t\t\tlet isTimeout = false;\n\t\t\tconst timeout = setTimeout(() => {\n\t\t\t\tisTimeout = true;\n\t\t\t\tif (socket === this.socket) {\n\t\t\t\t\tthis.socket = undefined;\n\t\t\t\t\tthis.connected = false;\n\t\t\t\t\tthis.connecting = false;\n\t\t\t\t\tthis.dispatchStateChangedEvent();\n\t\t\t\t}\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.closeStreamWebsocket(socket);\n\t\t\t\t}, 0);\n\t\t\t\treject(new Error('connect_timeout'));\n\t\t\t}, this.options.connectTimeout);\n\n\t\t\tsocket.onopen = (event: Event) => {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tif (isTimeout) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (event.target !== this.socket) {\n\t\t\t\t\tthis.closeStreamWebsocket(event.target as WebSocket);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.debug('pubs: stream socket connected', event);\n\t\t\t\tthis.connected = true;\n\t\t\t\tthis.connecting = false;\n\t\t\t\tthis.dispatchStateChangedEvent();\n\t\t\t\tthis.socket.onmessage = this.handleStreamWebSocketMessage.bind(this);\n\t\t\t\tresolve(event.target as WebSocket);\n\t\t\t};\n\t\t\tsocket.onclose = (event: CloseEvent) => {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tif (isTimeout) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (event.target !== this.socket) {\n\t\t\t\t\tif (!this.socket && !this.connecting && reconnector) {\n\t\t\t\t\t\tconsole.debug('pubs: socket closed, retry immediate reconnect now', event);\n\t\t\t\t\t\t// Directly try to reconnect. This makes reconnects fast\n\t\t\t\t\t\t// in the case where the connection was lost on the client\n\t\t\t\t\t\t// and has come back.\n\t\t\t\t\t\treconnector(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.debug('pubs: socket closed', event);\n\t\t\t\tthis.socket = undefined;\n\t\t\t\tthis.closing = false;\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.connecting = false;\n\t\t\t\tthis.dispatchStateChangedEvent();\n\t\t\t\tif (reconnector) {\n\t\t\t\t\treconnector();\n\t\t\t\t}\n\t\t\t};\n\t\t\tsocket.onerror = (event: Event) => {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\tif (isTimeout) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\treject(event);\n\t\t\t\t}, 0);\n\t\t\t\tif (event.target !== this.socket) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconsole.debug('pubs: socket error', event);\n\t\t\t\tthis.socket = undefined;\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.connecting = false;\n\t\t\t\tthis.dispatchErrorEvent({\n\t\t\t\t\tcode: 'websocket_error',\n\t\t\t\t\tmsg: '' + event,\n\t\t\t\t});\n\t\t\t\tthis.dispatchStateChangedEvent();\n\t\t\t};\n\n\t\t\tthis.closing = false;\n\t\t\tthis.socket = socket;\n\t\t});\n\t}\n\n\t/**\n\t * Encode and send JSON payload data via [[Pubs.socket]] connection.\n\t *\n\t * @param payload The payload data.\n\t * @param replyTimeout Timeout in milliseconds for reply callback. If 0,\n\t *        then no callback is expected and none is registered.\n\t * @returns Promise which resolves when the reply was received or immediately\n\t *          when no timeout was given.\n\t */\n\tpublic async sendStreamWebSocketPayload(payload: IStreamEnvelope, replyTimeout: number = 0): Promise<IStreamEnvelope> {\n\t\tif (replyTimeout === 0) {\n\t\t\treplyTimeout = this.options.streamAckTimeout;\n\t\t}\n\n\t\treturn new Promise<IStreamEnvelope>((resolve, reject) => {\n\t\t\tif (!this.connected || !this.socket || this.closing) {\n\t\t\t\treject(new Error('no_connection'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpayload.state = String(++websocketSequence);\n\t\t\ttry {\n\t\t\t\tthis.socket.send(JSON.stringify(payload));\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (replyTimeout > 0) {\n\t\t\t\tconst timeout = window.setTimeout(() => {\n\t\t\t\t\treject(new Error('timeout'));\n\t\t\t\t}, replyTimeout);\n\t\t\t\tthis.replyHandlers.set(payload.state, {resolve, timeout});\n\t\t\t} else {\n\t\t\t\tsetTimeout(resolve, 0);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Closes the provided websocket connection.\n\t *\n\t * @param socket Websocket to close.\n\t */\n\tprivate closeStreamWebsocket(socket: WebSocket): void {\n\t\tif (socket === this.socket) {\n\t\t\tthis.closing = true;\n\t\t}\n\t\tsocket.close();\n\t}\n\n\t/**\n\t * Process incoming Pubs stream Websocket payload data.\n\t *\n\t * @param event Websocket event holding payload data.\n\t */\n\tprivate handleStreamWebSocketMessage(event: MessageEvent): void {\n\t\tif (event.target !== this.socket) {\n\t\t\t(event.target as WebSocket).close();\n\t\t\treturn;\n\t\t}\n\n\t\tconst message: IStreamEnvelope = JSON.parse(event.data);\n\n\t\tswitch (message.type) {\n\t\t\tcase 'hello':\n\t\t\t\tconsole.debug('pubs: server hello', message);\n\t\t\t\tbreak;\n\t\t\tcase 'goodbye':\n\t\t\t\tconsole.debug('pubs: server goodbye, close connection', message);\n\t\t\t\tthis.reconnectAttempts = 1; // NOTE(longsleep): avoid instant reconnect.\n\t\t\t\tthis.closeStreamWebsocket(this.socket);\n\t\t\t\tthis.connected = false;\n\t\t\t\tbreak;\n\t\t\tcase 'ack':\n\t\t\t\t//console.debug('pubs: server ack', message);\n\t\t\t\tconst replyTimeout = this.replyHandlers.get(message.state);\n\t\t\t\tif (replyTimeout) {\n\t\t\t\t\tthis.replyHandlers.delete(message.state);\n\t\t\t\t\tclearTimeout(replyTimeout.timeout);\n\t\t\t\t\treplyTimeout.resolve(message);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('received ack without handler', message);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'event':\n\t\t\t\t//console.debug('pubs: server event', message.data, message.info);\n\t\t\t\tthis.dispatchStreamEvent(message.data, message.info);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.debug('pubs: unknown type', message.type, message);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * Generic event dispatcher. Dispatches callback functions based on event\n\t * types. Throws error for unknown event types. If a known event type has no\n\t * event handler registered, dispatchEvent does nothing.\n\t *\n\t * @param event Event to be dispatched.\n\t */\n\tprivate dispatchEvent(event: any): void {\n\t\tswitch (event.constructor.getName()) {\n\t\t\tcase PubsStateChangedEvent.getName():\n\t\t\t\tif (this.onstatechanged) {\n\t\t\t\t\tthis.onstatechanged(event);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PubsStreamEvent.getName():\n\t\t\t\tif (this.onstreamevent) {\n\t\t\t\t\tthis.onstreamevent(event);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PubsErrorEvent.getName():\n\t\t\t\tif (this.onerror) {\n\t\t\t\t\tthis.onerror(event);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error('unknown event: ' + event.constructor.getName());\n\t\t}\n\t}\n\n\t/**\n\t * Dispatch a new [[PubsStateChangedEvent]] implicitly created from the\n\t * associated Pubs current state.\n\t */\n\tprivate dispatchStateChangedEvent(): void {\n\t\tthis.dispatchEvent(new PubsStateChangedEvent(this));\n\t}\n\n\t/**\n\t * Dispatch a new [[PubsStreamEvent]] with the provided error details.\n\t *\n\t * @param data Data of the event to be dispatched.\n\t * @param info Info of the data.\n\t */\n\tprivate dispatchStreamEvent(data: any, info?: IStreamInfo): void {\n\t\tthis.dispatchEvent(new PubsStreamEvent(this, data, info));\n\t}\n\n\t/**\n\t * Dispatch a new [[PubsErrorEvent]] with the provided error details.\n\t *\n\t * @param err Error to be dispatched.\n\t */\n\tprivate dispatchErrorEvent(err: IPubsDataError): void {\n\t\tthis.dispatchEvent(new PubsErrorEvent(this, err));\n\t}\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--0!./src/pubs.ts","/*\n * Copyright 2018 Kopano\n *\n * Use of this source code is governed by a MIT license\n * that can be found in the LICENSE.txt file.\n *\n */\n\n'use strict';\n\nimport {\n\tIStreamInfo,\n} from './models'\n\n\nexport class PubsBaseEvent {\n\tpublic static eventName = 'PubsBaseEvent';\n\tpublic static getName(): string {\n\t\treturn this.eventName;\n\t}\n\n\tpublic target: any;\n\n\tconstructor(target: any) {\n\t\tthis.target = target;\n\t}\n}\n\nexport class PubsStateChangedEvent extends PubsBaseEvent {\n\tpublic static eventName = 'PubsStateChangedEvent';\n\n\tpublic connecting: boolean;\n\tpublic connected: boolean;\n\tpublic reconnecting: boolean;\n\n\tconstructor(target: any) {\n\t\tsuper(target);\n\n\t\tthis.connecting = target.connecting;\n\t\tthis.connected = target.connected;\n\t\tthis.reconnecting = target.reconnecting;\n\t}\n}\n\nexport class PubsStreamEvent extends PubsBaseEvent {\n\tpublic static eventName = 'PubsStreamEvent';\n\n\tpublic data: any;\n\tpublic info?: IStreamInfo;\n\n\tconstructor(target: any, data: any, info?: IStreamInfo) {\n\t\tsuper(target);\n\n\t\tthis.data = data;\n\t\tthis.info = info;\n\t}\n}\n\nexport class PubsErrorEvent extends PubsBaseEvent {\n\tpublic static eventName = 'PubsErrorEvent';\n\n\tpublic code: string;\n\tpublic msg: string;\n\n\tconstructor(target: any, details: any) {\n\t\tsuper(target);\n\n\t\tthis.code = details.code;\n\t\tthis.msg = details.msg;\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--0!./src/events.ts","/*\n * Copyright 2018 Kopano\n *\n * Use of this source code is governed by a MIT license\n * that can be found in the LICENSE.txt file.\n *\n */\n\n'use strict';\n\nexport interface IStreamEnvelope {\n\ttype: string;\n\tstate: string;\n\tinfo?: IStreamInfo;\n\tdata?: any;\n}\n\nexport interface IStreamWebsocketConnectResponse extends IResponse {\n\tstreamUrl: string;\n}\n\nexport interface IStreamReplyTimeoutRecord {\n\tresolve: (message: IStreamEnvelope) => void;\n\ttimeout: number;\n}\n\nexport interface IStreamInfo {\n\tref?: string;\n\ttopics?: string[];\n}\n\nexport interface IPubsDataError {\n\tcode: string;\n\tmsg?: string;\n}\n\nexport interface IErrorWithCodeAndMessage {\n\tcode: string;\n\tmsg?: string;\n}\n\nexport interface IResponse {\n\terror?: IErrorWithCodeAndMessage;\n}\n\nexport class PubsDataError implements IPubsDataError {\n\tpublic code: string;\n\tpublic msg: string = '';\n\n\tconstructor(data: IPubsDataError) {\n\t\tthis.code = data.code;\n\t\tif (data.msg) {\n\t\t\tthis.msg = data.msg;\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--0!./src/models.ts","/*\n * Copyright 2018 Kopano\n *\n * Use of this source code is governed by a MIT license\n * that can be found in the LICENSE.txt file.\n *\n */\n\n'use strict';\n\n/**\n * @private\n */\nexport function makeAbsoluteURL(url: string): string {\n\tconst a = document.createElement('a');\n\ta.href = url;\n\treturn a. href;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./node_modules/tslint-loader??ref--0!./src/utils.ts"],"sourceRoot":""}