/*!
 * Copyright (c) 2018 Kopano
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 * 
 * @version 8de76a3 (2018-02-20T16:53:22Z) ES2015
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define("Pubs",[],e):"object"==typeof exports?exports.Pubs=e():t.Pubs=e()}("undefined"!=typeof self?self:this,function(){return function(t){var e={};function n(o){if(e[o])return e[o].exports;var s=e[o]={i:o,l:!1,exports:{}};return t[o].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=t,n.c=e,n.d=function(t,e,o){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:o})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="/dist/",n(n.s=0)}([function(t,e,n){t.exports=n(1)},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(2),s=n(3),c=n(4),i=this&&this.__awaiter||function(t,e,n,o){return new(n||(n=Promise))(function(s,c){function i(t){try{a(o.next(t))}catch(t){c(t)}}function r(t){try{a(o.throw(t))}catch(t){c(t)}}function a(t){t.done?s(t.value):new n(function(e){e(t.value)}).then(i,r)}a((o=o.apply(t,e||[])).next())})};const r={authorizationValue:"",authorizationType:"Bearer",connectTimeout:5e3,reconnectInterval:1e3,maxReconnectInterval:3e4,reconnectEnabled:!0,reconnectFactor:1.5,reconnectSpreader:500,heartbeatInterval:5e3,streamAckTimeout:2e4};let a=0;class h{constructor(t="",e){this.connecting=!1,this.connected=!1,this.reconnecting=!1,this.closing=!1,this.reconnector=0,this.reconnectAttempts=0,this.baseURI=t.replace(/\/$/,""),this.options=Object.assign({},r,h.defaultOptions,e),this.replyHandlers=new Map}static init(t){this.defaultOptions=Object.assign({},r,t)}connect(){return i(this,void 0,void 0,function*(){console.debug("pubs: connect"),clearTimeout(this.reconnector);const t=(t=!1)=>{if(clearTimeout(this.reconnector),!this.reconnecting)return;let e=this.options.reconnectInterval;t||((e*=Math.trunc(Math.pow(this.options.reconnectFactor,this.reconnectAttempts)))>this.options.maxReconnectInterval&&(e=this.options.maxReconnectInterval),e+=Math.floor(Math.random()*this.options.reconnectSpreader)),this.reconnector=window.setTimeout(()=>{this.connect()},e),this.reconnectAttempts++};return this.reconnecting=this.options.reconnectEnabled||!0,this.connecting=!0,this.dispatchStateChangedEvent(),new Promise((e,n)=>i(this,void 0,void 0,function*(){let o,c="";this.options.authorizationType&&this.options.authorizationValue&&(c=this.options.authorizationType+" "+this.options.authorizationValue);try{o=yield this.fetchStreamWebSocketConnect(c)}catch(t){console.warn("pubs: failed to fetch websocket connection details",t),o={streamUrl:"",error:{code:"request_failed",msg:""+t}}}if(console.debug("connect result",o),!o.streamUrl)return this.connecting=!1,this.dispatchStateChangedEvent(),void(this.reconnecting?(o.error&&"http_error_403"===o.error.code&&(console.warn("pubs: giving up reconnect, as connect returned forbidden",o.error.msg),this.reconnecting=!1,this.dispatchStateChangedEvent(),this.dispatchErrorEvent(o.error)),t()):o.error?n(new s.a(o.error)):n(new s.a({code:"unknown_error",msg:""})));let i=o.streamUrl;i.includes("://")||(i=this.baseURI+i),this.connectStreamWebSocket(i,this.reconnecting?t:void 0).then(()=>{this.reconnectAttempts=0,console.debug("pubs: connection established",this.reconnectAttempts),e()},e=>{console.warn("pubs: connection failed",e,!!this.reconnecting),this.reconnecting?t():n(e)})}))})}sub(t){return i(this,void 0,void 0,function*(){return this.pubsub("sub",t)})}unsub(t){return i(this,void 0,void 0,function*(){return this.pubsub("unsub",t)})}pubsub(t,e){return i(this,void 0,void 0,function*(){const n={type:t,state:"",info:{topics:e}};return this.sendStreamWebSocketPayload(n).then(()=>{console.log("pubs: send done")})})}fetchStreamWebSocketConnect(t){return i(this,void 0,void 0,function*(){const e=this.baseURI+"/api/pubs/v1/stream/connect",n=new Headers;return t&&n.set("Authorization",t),fetch(e,{headers:n,method:"POST",mode:"cors"}).then(t=>t.ok?t.json():{error:{code:"http_error_"+t.status,msg:t.statusText}})})}connectStreamWebSocket(t,e){return i(this,void 0,void 0,function*(){return console.debug("pubs: connect stream websocket",t),new Promise((n,o)=>{if(this.socket){console.warn("pubs: closing existing socket connection");const t=this.socket;this.socket=void 0,this.connected=!1,this.closeStreamWebsocket(t)}const s=Object(c.a)(t).replace(/^https:\/\//i,"wss://").replace(/^http:\/\//i,"ws://");console.debug("pubs: connecting stream socket URL",s);const i=new WebSocket(s+"?v=1");let r=!1;const a=setTimeout(()=>{r=!0,i===this.socket&&(this.socket=void 0,this.connected=!1,this.connecting=!1,this.dispatchStateChangedEvent()),setTimeout(()=>{this.closeStreamWebsocket(i)},0),o(new Error("connect_timeout"))},this.options.connectTimeout);i.onopen=(t=>{clearTimeout(a),r||(t.target===this.socket?(console.debug("pubs: stream socket connected",t),this.connected=!0,this.connecting=!1,this.dispatchStateChangedEvent(),this.socket.onmessage=this.handleStreamWebSocketMessage.bind(this),n(t.target)):this.closeStreamWebsocket(t.target))}),i.onclose=(t=>{clearTimeout(a),r||(t.target===this.socket?(console.debug("pubs: socket closed",t),this.socket=void 0,this.closing=!1,this.connected=!1,this.connecting=!1,this.dispatchStateChangedEvent(),e&&e()):this.socket||this.connecting||!e||(console.debug("pubs: socket closed, retry immediate reconnect now",t),e(!0)))}),i.onerror=(t=>{clearTimeout(a),r||(setTimeout(()=>{o(t)},0),t.target===this.socket&&(console.debug("pubs: socket error",t),this.socket=void 0,this.connected=!1,this.connecting=!1,this.dispatchErrorEvent({code:"websocket_error",msg:""+t}),this.dispatchStateChangedEvent()))}),this.closing=!1,this.socket=i})})}sendStreamWebSocketPayload(t,e=0){return i(this,void 0,void 0,function*(){return 0===e&&(e=this.options.streamAckTimeout),new Promise((n,o)=>{if(this.connected&&this.socket&&!this.closing){t.state=String(++a);try{this.socket.send(JSON.stringify(t))}catch(t){return void o(t)}if(e>0){const s=window.setTimeout(()=>{o(new Error("timeout"))},e);this.replyHandlers.set(t.state,{resolve:n,timeout:s})}else setTimeout(n,0)}else o(new Error("no_connection"))})})}closeStreamWebsocket(t){t===this.socket&&(this.closing=!0),t.close()}handleStreamWebSocketMessage(t){if(t.target!==this.socket)return void t.target.close();const e=JSON.parse(t.data);switch(e.type){case"hello":console.debug("pubs: server hello",e);break;case"goodbye":console.debug("pubs: server goodbye, close connection",e),this.reconnectAttempts=1,this.closeStreamWebsocket(this.socket),this.connected=!1;break;case"ack":const t=this.replyHandlers.get(e.state);t?(this.replyHandlers.delete(e.state),clearTimeout(t.timeout),t.resolve(e)):console.log("received ack without handler",e);break;case"event":this.dispatchStreamEvent(e.data,e.info);break;default:console.debug("pubs: unknown type",e.type,e)}}dispatchEvent(t){switch(t.constructor.getName()){case o.b.getName():this.onstatechanged&&this.onstatechanged(t);break;case o.c.getName():this.onstreamevent&&this.onstreamevent(t);break;case o.a.getName():this.onerror&&this.onerror(t);break;default:throw new Error("unknown event: "+t.constructor.getName())}}dispatchStateChangedEvent(){this.dispatchEvent(new o.b(this))}dispatchStreamEvent(t,e){this.dispatchEvent(new o.c(this,t,e))}dispatchErrorEvent(t){this.dispatchEvent(new o.a(this,t))}}e.Pubs=h,h.version="8de76a3"},function(t,e,n){"use strict";class o{constructor(t){this.target=t}static getName(){return this.eventName}}o.eventName="PubsBaseEvent";class s extends o{constructor(t){super(t),this.connecting=t.connecting,this.connected=t.connected,this.reconnecting=t.reconnecting}}e.b=s,s.eventName="PubsStateChangedEvent";class c extends o{constructor(t,e,n){super(t),this.data=e,this.info=n}}e.c=c,c.eventName="PubsStreamEvent";class i extends o{constructor(t,e){super(t),this.code=e.code,this.msg=e.msg}}e.a=i,i.eventName="PubsErrorEvent"},function(t,e,n){"use strict";e.a=class{constructor(t){this.msg="",this.code=t.code,t.msg&&(this.msg=t.msg)}}},function(t,e,n){"use strict";e.a=function(t){const e=document.createElement("a");return e.href=t,e.href}}]).Pubs});
//# sourceMappingURL=pubs.js.map